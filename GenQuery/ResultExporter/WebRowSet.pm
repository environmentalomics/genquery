#!perl
use strict; use warnings;

#This module encapsulates methods for writing a result table out to XML
#as a Java WebRowSet: http://download-llnw.oracle.com/javase/6/docs/api/javax/sql/rowset/WebRowSet.html
#and see: http://koders.com/perl/fidB3B01E73AF21835E81257A61112914778DF1499F.aspx?s=cgi#L57
#
# Java users should just be able to create a WebRowSetImpl and call readXML.
# Perl users can use this quick and dirty parser:
#
#  $doc = XML::DOM::Parser->new()->parsefile("webrowset.xml");
#  @headings = map {$_->getData} $doc->findnodes('//column-name/text()');
#  push @data, map {[map {$_->getData} $_->findnodes('columnValue/text()')]}
#                      $doc->findnodes('//currentRow');
#
#What I'm talking about:
#   <webRowSet>
#	<properties>
#	  <...>
#	</properties>
#	<metadata>
#	  <column-count>4</column-count>			
#	  <column-definition>
#	     <column-index>1</column-index>     //SQL starts at 1 for columns
#	     <column-label>foo</column-label>   //compulsory, maybe not unique - what appears on the HTML view
#	     <column-name>bar</column-name>	//compulsory, unique
#	     <column-type-name>int8</column-type-name>    //Extract the type from the DB
#	  </column-definition>
#	  ...
#	</metadata>
#	<data>
#	   <currentRow>
#	     <columnValue>col1</columnValue>
#	     <columnValue>col2</columnValue>
#	     <columnValue></null></columnValue>
#	     <columnValue>1234</columnValue>
#          <currentRow>
#	</data>
#   </webRowSet>
#
#   There is no way to represent links, as found in custom XML export.
#   Column types need to be right for Java to be happy.  I'll use:
#
#   text = 12 (or default)
#   int = 4
#   numeric = 2
#   timestampz = 93 (or should I just send as string??)
#   time = 92
# Correct timestamps are generated by parsing the string representation.  Really
# I should be able to get the integer direct form the DB but DBI doesn't make
# this easy.
# If Date::Parse isn't available these just get left as strings.

package GenQuery::ResultExporter::WebRowSet;

use XML::Writer;
use Data::Dumper;
use GenQuery::ResultTable;

#Nice to have this.
eval{ require Date::Parse };
    
sub new
{
    my ($class, @params) = @_;

    my $this = { mimetype => 'text/xml', opts => $params[0] };

    bless $this => $class;
}

sub get
{
    (my $this, $_) = @_;

    /^_/ ? undef : $this->{$_};
}

sub _type_to_number
{
    my ($typedef, $parsedates) = @_;
    my $type_wrs_number = 0;

    #If $typedef is undefined we go for TEXT
    if(!$typedef)
    {
	return { TYPE_NAME => 'text', TYPE_WRS_NUMBER => 12 };
    }
    
    for(lc($typedef->{TYPE_NAME}))
    {
	#Text is obvious
	/text/ and $type_wrs_number = 12, last;
	/unknown/ and $type_wrs_number = 12, last;
	/int/ and $type_wrs_number = 4, last;
	/numeric/ and $type_wrs_number = 2, last;

	#Dates and times are left as text unless I have the tools to process them
	if($INC{'Date/Parse.pm'} && $parsedates)
	{
	    /^date/ and $type_wrs_number = 93, last;
	    /^timestamp/ and $type_wrs_number = 93, last;
	    /^time/ and $type_wrs_number = 92, last;
	}
    }

    #Debug - FIXME
    die Dumper("Unknown type def:", $typedef) unless $type_wrs_number;

    $typedef->{TYPE_WRS_NUMBER} = $type_wrs_number || 12;
    return $typedef;
}

sub _format
{
    my ($data, $type_number) = @_;

    #Format some data.  This is mainly for dates right now.
    if($type_number == 93)
    {
	$data = int(Date::Parse::str2time($data)*1000);
    }
    elsif($type_number == 92)
    {
	$data = int(Date::Parse::str2time("70-1-1 $data")*1000);
    }
    $data;
}

sub dump
{
    my ($this, $rs, $opts) = @_;
    $opts ||= $this->{opts};
    my $res;
    my $nn;

    #Note that opts is tainted at this point as it has come straight from the
    #page request.
    my $xw = new XML::Writer(OUTPUT => \$res, NEWLINES => 1, DATA_MODE => 1);
    
    #Check columns
    my $names = $rs->get_display_headings();
    my $internalnames = $rs->get_internal_headings();
    my $flags = $rs->{column_flags};
    my $keeplinks = $opts->{keeplinks};
    my $parsedates = ($opts->{parsedates} || 'yes') ne 'no';

    my $types = $rs->get_types();

    #Knock out flags from internalnames or else add to names
    #depending on option to include the special columns
    if($keeplinks)
    {
	$nn = 0;
	$names = [map {$_ ? ( $_ == GenQuery::ResultTable::HIDE ? '_hide' : '_link' )
			  : shift(@$names)} @$flags];
    }
    else
    {
	$nn = 0;
	$internalnames = [grep {!$flags->[$nn++]} @$internalnames];
	$nn = 0;
	$types = [grep {!$flags->[$nn++]} @$types];
    }

    #Ensure that the internal names are unique - they should be anyway
    make_unique($internalnames);

    #A header seems like a good start
    $xw->xmlDecl();
    
    #Start XML - the namespace declarations can probably be left out but they are 
    #standard.
    $xw->startTag('webRowSet', 
		    'xmlns' => "http://java.sun.com/xml/ns/jdbc",
		    'xmlns:xsi' => "http://www.w3.org/2001/XMLSchema-instance",
		    'xsi:schemaLocation' => 
			"http://java.sun.com/xml/ns/jdbc http://java.sun.com/xml/ns/jdbc/webrowset.xsd"
		    );
    #Properties
    #As it stands the Exporter can't see the name of the query or the actual SLQ
    #that was run.  Actually I don't want to reveal the SQL, but it would be nice to record
    #the parameters.
    $xw->startTag('properties');
    $xw->dataElement(command => 'GenQuery ResultExporter');
    $xw->dataElement(url => $rs->{permalink}) if $rs->{permalink};
    $xw->dataElement('read-only' => 'true');
    $xw->endTag('properties');

    #Metadata
    $xw->startTag('metadata');
    $xw->dataElement('column-count' => scalar(@$names));
    my $colidx = 0;
    for(@$names)
    {
	#Annotate the types with the appropriate number
	$types->[$colidx] = _type_to_number($types->[$colidx], $parsedates);

	$xw->startTag('column-definition');

	$xw->dataElement('column-index' => $colidx + 1);
	$xw->dataElement('auto-increment' => 'false');
	$xw->dataElement('case-sensitive' => 'true');
	$xw->dataElement('currency' => 'false');
	$xw->dataElement('nullable' => 2);
	$xw->dataElement('column-label' => $names->[$colidx]);
	$xw->dataElement('column-name' => $internalnames->[$colidx]);
	$xw->dataElement('column-type' => $types->[$colidx]->{TYPE_WRS_NUMBER});
	$xw->dataElement('column-type-name' => $types->[$colidx]->{TYPE_NAME});

	$xw->endTag('column-definition');
	$colidx++;
    }
    $xw->endTag('metadata');


    #Dump rows
    $xw->startTag('data');
    for my $row (@{$rs->{res}})
    {
	$xw->startTag('currentRow');

	my $colcount = scalar(@$row);
	$colidx = 0;
	for($nn = 0 ; $nn < $colcount ; $nn++)
	{
	    if($keeplinks || !$flags->[$nn])
	    {
		#Data goes through _format() before being printed.
		if(defined $row->[$nn])
		{
		    $xw->dataElement(columnValue => 
				      _format($row->[$nn], $types->[$colidx]->{TYPE_WRS_NUMBER}));
		}
		else
		{
		    $xw->startTag('columnValue');
		    $xw->emptyTag('null');
		    $xw->endTag('columnValue');
		}
		$colidx++;
	    }
	    #else do nothing
	}
	$xw->endTag('currentRow');
    }
    $xw->endTag('data');

    #Done XML
    $xw->endTag('webRowSet');
    $xw->end();

    $res;
}

#private sub
sub make_unique
{
    my $array = shift;

    #Hmmm, I'd like to have 'foo', 'bar', 'foo', 'foo' transformed into 'foo', 'bar', 'foo.1', 'foo.2'
    #I guess that something silly like 'foo', 'bar', 'foo', 'foo.1' becomes 'foo', 'bar', 'foo.1', 'foo.1.1'
    
    my %sub;

    for(@$array)
    {
	while(my $px = $sub{$_}++)
	{
	    $_ .= ".$px";
	}
    }
}

1;
